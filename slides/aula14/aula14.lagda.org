#    -*- mode: org -*-
#+TITLE: Evidências em Agda
#+SUBTITLE: PCC102 - Teoria da computação
#+AUTHOR: Rodrigo Ribeiro
#+EMAIL: rodrigo.ribeiro@ufop.edu.br


* Setup inicial

#+BEGIN_SRC agda2
module aula14 where
  
open import Basics.Level

open import Data.Function.Function

open import Data.Bool.Bool
open import Data.Empty.Empty
open import Data.Product.Product
open import Data.Nat.Nat
open import Data.Unit.Unit
  
open import Relation.Equality.Propositional
#+END_SRC

* Objetivos

- Relacionar booleanos e tipos em Agda.

- Apresentar o conceito de _proof by reflection_.

* Evidência e Computação

- Vamos revisar a relação ≤ sobre ℕ:

#+BEGIN_SRC agda2
infix 4 _≤_

data _≤_ : ℕ → ℕ → Set where
  z≤n : ∀ {n} → 0 ≤ n
  s≤s : ∀ {n m} → n ≤ m
                → (suc n) ≤ (suc m) 
#+END_SRC

* Evidência e Computação

- O tipo ≤ representa uma _evidência_ para a
relação menor ou igual sobre ℕ.

#+BEGIN_SRC agda2
_ : 2 ≤ 4
_ = s≤s (s≤s z≤n)
#+END_SRC

* Evidência e Computação

- Evidência para proposição (demonstração) é
algo mais "forte" que um resultado booleano.

* Evidência e Computação

- Definição do teste ≤.

#+begin_src agda2
infix 4 _≤ᵇ_

_≤ᵇ_ : ℕ → ℕ → Bool
zero ≤ᵇ m      = true
suc n ≤ᵇ zero  = false
suc n ≤ᵇ suc m = n ≤ᵇ m
#+end_src
  

* Evidência e Computação

- O tipo `2 ≤ 4` representa evidência de que
2 é menor ou igual a 4.

* Evidência e Computação

- Por sua vez, `2 ≤ᵇ 4` denota uma computação
que irá produzir `true`, como resultado.

* Evidência e Computação

- Dessa forma, temos que um valor de tipo `2 ≤ 4`
possui "mais informação" que a computação `2 ≤ᵇ 4`.

* Evidência e Computação

- Como relacionar o tipo ≤ e a função ≤ᵇ?

- Provando soundness e completeness!

* Evidência e Computação

- Para facilitar a demonstração dessas propriedades,
vamos utilizar uma função que associa uma evidência
a valores booleanos.

#+begin_src agda2
T : Bool → Set 
T true  = ⊤
T false = ⊥
#+end_src

* Evidência e Computação

- Relacionando `T` e `≡`:

#+begin_src agda2
T→≡ : (b : Bool) → T b → b ≡ true
T→≡ true  tt = refl
T→≡ false ()

≡→T : {b : Bool} → b ≡ true → T b
≡→T refl = tt
#+end_src

* Evidência e Computação

- Soundness for ≤ᵇ

#+begin_src agda2
≤ᵇ-sound : ∀ {n m} → T (n ≤ᵇ m) → n ≤ m
≤ᵇ-sound {zero} {m} p = z≤n
≤ᵇ-sound {suc n} {suc m} p = s≤s (≤ᵇ-sound p)
#+end_src

* Evidência e Computação

- Completeness for ≤ᵇ

#+begin_src agda2
≤ᵇ-complete : ∀ {n m} → n ≤ m → T (n ≤ᵇ m)
≤ᵇ-complete z≤n = tt
≤ᵇ-complete (s≤s n≤m) = ≤ᵇ-complete n≤m
#+end_src

* Evidência e Computação

- Há alguma maneira de combinar a computação
  oferecida pelo teste baseado em valores
  booleanos e a produção de evidência?

- Sim! Para isso vamos utilizar um novo tipo.

* Evidência e Computação

- `Dec` é um tipo que representa proposições
  decidíveis.

#+begin_src agda2
data Dec {l}(A : Set l) : Set l where
  yes : A   → Dec A
  no  : ¬ A → Dec A
#+end_src

* Evidência e Computação

- Usando `Dec` podemos decidir desigualdades.

- Primeiro, um resultado auxiliar.

#+begin_src agda2 
≤-suc-inv : ∀ {n m} → suc n ≤ suc m → n ≤ m
≤-suc-inv (s≤s p) = p
#+end_src

* Evidência e Computação

- Decidindo a desigualdade

#+begin_src agda2
_≤?_ : ∀ (n m : ℕ) → Dec (n ≤ m)
zero ≤? m      = yes z≤n
suc n ≤? zero  = no (λ ())
suc n ≤? suc m with n ≤? m
...| yes n≤m = yes (s≤s n≤m)
...| no ¬n≤m = no (¬n≤m ∘ ≤-suc-inv)
#+end_src

* Evidência e Computação

- Convertendo `Dec` em um booleano

#+begin_src agda2
⌞_⌟ : ∀ {l}{A : Set l} → Dec A → Bool
⌞ yes x ⌟ = true
⌞ no x ⌟  = false
#+end_src

* Evidência e Computação

- Obtemos a versão do teste para booleanos
simplesmente usando a função de conversão.

#+begin_src agda2
_≤ᵇ'_ : ℕ → ℕ → Bool
n ≤ᵇ' m = ⌞ n ≤? m ⌟
#+end_src

* Evidência e Computação

- Se o tipo `Dec` é equivalente a Bool,
  então existem funções sobre `Dec`
  similares aos conectivos da lógica?

- A resposta é sim!

* Evidência e Computação

- Conjunção para `Dec`

#+begin_src agda2
infixr 6 _×-dec_

_×-dec_ : ∀ {a b}{A : Set a}{B : Set b} → Dec A → Dec B → Dec (A × B)
yes x ×-dec yes x₁ = yes (x , x₁)
yes x ×-dec no x₁ = no (λ z → x₁ (proj₂ z))
no x ×-dec db = no (λ z → x (proj₁ z))
#+end_src

* Proof by reflection
  
- Uma aplicação importante do apresentado até o momento
é a técnica de proof by reflection.

- Intuivamente, essa técnica usa o mecanismo de inferência
de argumentos implícitos de Agda para calcular deduções.

- Vamos ver essa técnica em um exemplo.
  
* Proof by reflection

- Recordando: predicado para números pares.

#+begin_src agda2
True : ∀ {l}{Q : Set l} → Dec Q → Set
True Q = T ⌞ Q ⌟

data Even : ℕ → Set where
  zero : Even 0
  suc  : ∀ {n} → Even n
               → Even (2 + n)

Even-inv : ∀ {n} → Even (2 + n) → Even n
Even-inv (suc p) = p

Even-dec : (n : ℕ) → Dec (Even n)
Even-dec zero = yes zero
Even-dec (suc zero) = no (λ ())
Even-dec (suc (suc n)) with Even-dec n
...| yes p = yes (suc p)
...| no ¬p = no (¬p ∘ Even-inv)

half-refl : (n : ℕ) → True (Even-dec n) → ℕ
half-refl zero t = zero
half-refl (suc (suc n)) t = n

half : ℕ → ℕ
half n = half-refl n tt
#+end_src

* Proof by reflection

- O mecanismo de inferência de Agda é capaz de calcular
evidências para registros por preencher se este
for capaz de inferir todos os campos do registro.

* Proof by reflection

-  

* Referências

- Kokke, Wen; Wadler, Phillip; Siek, Jeremy.
Programming Languages Foundations in Agda.

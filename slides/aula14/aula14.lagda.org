#    -*- mode: org -*-
#+TITLE: Evidências em Agda
#+SUBTITLE: PCC116 - Lógica aplicada à computação
#+AUTHOR: Rodrigo Ribeiro
#+EMAIL: rodrigo.ribeiro@ufop.edu.br


* Setup inicial

#+BEGIN_SRC agda2
module aula14 where
  
open import Basics.Level

open import Data.Function.Function

open import Data.Bool.Bool hiding (T ; T→≡ ; ≡→T)
open import Data.Empty.Empty
open import Data.Product.Product
open import Data.Nat.Nat
open import Data.Unit.Unit
  
open import Relation.Equality.Propositional
#+END_SRC

* Objetivos

- Relacionar booleanos e tipos em Agda.

- Apresentar o conceito de _proof by reflection_.

* Evidência e Computação

- Vamos revisar a relação < sobre ℕ:

#+BEGIN_SRC agda2
infix 4 _<_

data _<_ : ℕ → ℕ → Set where
  z<s : ∀ {n} → 0 < suc n
  s<s : ∀ {n m} → n < m
                → (suc n) < (suc m) 
#+END_SRC

* Evidência e Computação

- O tipo < representa uma _evidência_ para a
relação menor sobre ℕ.

#+BEGIN_SRC agda2
_ : 2 < 4
_ = s<s (s<s z<s)
#+END_SRC

* Evidência e Computação

- Evidência para proposição (demonstração) é
algo mais "forte" que um resultado booleano.

* Evidência e Computação

- Definição do teste ≤.

#+begin_src agda2
infix 4 _<ᵇ_

_<ᵇ_ : ℕ → ℕ → Bool
zero <ᵇ zero    = false
zero <ᵇ (suc _) = true
suc n <ᵇ zero   = false
suc n <ᵇ suc m  = n <ᵇ m
#+end_src
  

* Evidência e Computação

- O tipo `2 < 4` representa evidência de que
2 é menor que 4.

* Evidência e Computação

- Por sua vez, `2 <ᵇ 4` denota uma computação
que irá produzir `true`, como resultado.

* Evidência e Computação

- Dessa forma, temos que um valor de tipo `2 < 4`
possui "mais informação" que a computação `2 <ᵇ 4`.

* Evidência e Computação

- Como relacionar o tipo < e a função <ᵇ?

- Provando soundness e completeness!

* Evidência e Computação

- Para facilitar a demonstração dessas propriedades,
vamos utilizar uma função que associa uma evidência
a valores booleanos.

#+begin_src agda2
T : Bool → Set 
T true  = ⊤
T false = ⊥
#+end_src

* Evidência e Computação

- Relacionando `T` e `≡`:

#+begin_src agda2
T→≡ : (b : Bool) → T b → b ≡ true
T→≡ true  tt = refl
T→≡ false ()

≡→T : {b : Bool} → b ≡ true → T b
≡→T refl = tt
#+end_src

* Evidência e Computação

- Soundness for <ᵇ

#+begin_src agda2
<ᵇ-sound : ∀ {n m} → T (n <ᵇ m) → n < m
<ᵇ-sound {zero} {suc m} p = z<s
<ᵇ-sound {suc n} {suc m} p = s<s (<ᵇ-sound p)
#+end_src

* Evidência e Computação

- Completeness for <ᵇ

#+begin_src agda2
<ᵇ-complete : ∀ {n m} → n < m → T (n <ᵇ m)
<ᵇ-complete z<s = tt
<ᵇ-complete (s<s p) = <ᵇ-complete p
#+end_src

* Evidência e Computação

- Há alguma maneira de combinar a computação
  oferecida pelo teste baseado em valores
  booleanos e a produção de evidência?

- Sim! Para isso vamos utilizar um novo tipo.

* Evidência e Computação

- `Dec` é um tipo que representa proposições
  decidíveis.

#+begin_src agda2
data Dec {l}(A : Set l) : Set l where
  yes : A   → Dec A
  no  : ¬ A → Dec A
#+end_src

* Evidência e Computação

- Usando `Dec` podemos decidir desigualdades.

- Primeiro, um resultado auxiliar.

#+begin_src agda2 
<-suc-inv : ∀ {n m} → suc n < suc m → n < m
<-suc-inv (s<s p) = p
#+end_src

* Evidência e Computação

- Decidindo a desigualdade

#+begin_src agda2
_<?_ : ∀ (n m : ℕ) → Dec (n < m)
zero <? zero = no (λ ())
zero <? suc m = yes z<s
suc n <? zero = no (λ ())
suc n <? suc m with n <? m
...| yes n<m = yes (s<s n<m)
...| no ¬n<m = no (¬n<m ∘ <-suc-inv)
#+end_src

* Evidência e Computação

- Convertendo `Dec` em um booleano

#+begin_src agda2
⌞_⌟ : ∀ {l}{A : Set l} → Dec A → Bool
⌞ yes x ⌟ = true
⌞ no x ⌟  = false
#+end_src

* Evidência e Computação

- Obtemos a versão do teste para booleanos
simplesmente usando a função de conversão.

#+begin_src agda2
_≤ᵇ'_ : ℕ → ℕ → Bool
n ≤ᵇ' m = ⌞ n <? m ⌟
#+end_src

* Evidência e Computação

- Se o tipo `Dec` é equivalente a Bool,
  então existem funções sobre `Dec`
  similares aos conectivos da lógica?

- A resposta é sim!

* Evidência e Computação

- Conjunção para `Dec`

#+begin_src agda2
infixr 6 _×-dec_

_×-dec_ : ∀ {a b}{A : Set a}{B : Set b} → Dec A → Dec B → Dec (A × B)
yes x ×-dec yes x₁ = yes (x , x₁)
yes x ×-dec no x₁ = no (λ z → x₁ (proj₂ z))
no x ×-dec db = no (λ z → x (proj₁ z))
#+end_src

* Proof by reflection
  
- Uma aplicação importante do apresentado até o momento
é a técnica de proof by reflection.

- Intuivamente, essa técnica usa o mecanismo de inferência
de argumentos implícitos de Agda para calcular deduções.

* Proof by reflection

* Proof by reflection

- O mecanismo de inferência de Agda é capaz de calcular
evidências para registros por preencher se este
for capaz de inferir todos os campos do registro.

- Vamos ver essa técnica em um exemplo.
  
* Proof by reflection

- Considere a tarefa de obter a metade de um número
natural fornecido como entrada.

- Podemos supor que essa tarefa faz sentido apenas
para números naturais pares.

* Proof by reflection

- Recordando: predicado para números pares.

#+begin_src agda2
data Even : ℕ → Set where
  zero : Even 0
  suc  : ∀ {n} → Even n
               → Even (2 + n)

Even-inv : ∀ {n} → Even (2 + n) → Even n
Even-inv (suc p) = p
#+end_src

* Proof by reflection

- Decidibilidade do predicado `Even`.

#+begin_src agda2
Even-dec : (n : ℕ) → Dec (Even n)
Even-dec zero = yes zero
Even-dec (suc zero) = no (λ ())
Even-dec (suc (suc n)) with Even-dec n
...| yes p = yes (suc p)
...| no ¬p = no (¬p ∘ Even-inv)
#+end_src

* Proof by reflection

- Determinando se um valor de tipo `Dec` é
"verdadeiro".

#+begin_src agda2
True : ∀ {l}{Q : Set l} → Dec Q → Set
True Q = T ⌞ Q ⌟

_ : True (2 <? 3)
_ = tt
#+end_src

* Proof by reflection

- Usando as peças anteriores, podemos definir uma função
para determinar a metade de um número, caso ele seja par.

#+begin_src agda2
half-refl : ∀ (n : ℕ) → True (Even-dec n) → ℕ
half-refl zero tt = zero
half-refl (suc (suc n)) _ = n
#+end_src

* Proof by reflection

- Exemplo

#+begin_src agda2
two : ℕ
two = half-refl 1000 _
#+end_src

* Proof by reflection

- Ao tentar chamar a função `half-refl` sobre um
valor ímpar, o typechecker de Agda não será capaz
de inferir a dedução (`tt`) para `True (Even-dec n)`,
gerando um erro de tipo.

* Referências

- Kokke, Wen; Wadler, Phillip; Siek, Jeremy.
Programming Languages Foundations in Agda.

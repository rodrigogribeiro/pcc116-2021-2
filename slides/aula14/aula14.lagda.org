#    -*- mode: org -*-
#+TITLE: Evidências em Agda
#+SUBTITLE: PCC116 - Lógica aplicada à computação
#+AUTHOR: Rodrigo Ribeiro
#+EMAIL: rodrigo.ribeiro@ufop.edu.br

* Setup inicial

#+BEGIN_SRC agda2
module aula14 where
  
open import Basics.Level

open import Data.Function.Function

open import Data.Bool.Bool hiding (T ; T→≡ ; ≡→T)
open import Data.Empty.Empty
open import Data.Product.Product
open import Data.Nat.Nat
open import Data.Unit.Unit
  
open import Relation.Equality.Propositional
#+END_SRC

* Objetivos

- Relacionar booleanos e tipos em Agda.

- Apresentar o conceito de _proof by reflection_.

* Evidência e Computação

- Vamos revisar a relação < sobre ℕ:

#+BEGIN_SRC agda2
infix 4 _<_

data _<_ : ℕ → ℕ → Set where
  z<s : ∀ {n} → 0 < suc n
  s<s : ∀ {n m} → n < m
                → (suc n) < (suc m) 
#+END_SRC

* Evidência e Computação

- O tipo < representa uma _evidência_ para a
relação menor sobre ℕ.

#+BEGIN_SRC agda2
_ : 2 < 4
_ = s<s (s<s z<s)
#+END_SRC

* Evidência e Computação

- Evidência para proposição (demonstração) é
algo mais "forte" que um resultado booleano.

* Evidência e Computação

- Definição do teste ≤.

#+begin_src agda2
infix 4 _<ᵇ_

_<ᵇ_ : ℕ → ℕ → Bool
zero <ᵇ zero    = false
zero <ᵇ (suc _) = true
suc n <ᵇ zero   = false
suc n <ᵇ suc m  = n <ᵇ m
#+end_src
  

* Evidência e Computação

- O tipo `2 < 4` representa evidência de que
2 é menor que 4.

* Evidência e Computação

- Por sua vez, `2 <ᵇ 4` denota uma computação
que irá produzir `true`, como resultado.

* Evidência e Computação

- Dessa forma, temos que um valor de tipo `2 < 4`
possui "mais informação" que a computação `2 <ᵇ 4`.

* Evidência e Computação

- Como relacionar o tipo < e a função <ᵇ?

- Provando soundness e completeness!

* Evidência e Computação

- Para facilitar a demonstração dessas propriedades,
vamos utilizar uma função que associa uma evidência
a valores booleanos.

#+begin_src agda2
T : Bool → Set 
T true  = ⊤
T false = ⊥
#+end_src

* Evidência e Computação

- Relacionando `T` e `≡`:

#+begin_src agda2
T→≡ : (b : Bool) → T b → b ≡ true
T→≡ true  tt = refl
T→≡ false ()

≡→T : {b : Bool} → b ≡ true → T b
≡→T refl = tt
#+end_src

* Evidência e Computação

- Soundness for <ᵇ

#+begin_src agda2
<ᵇ-sound : ∀ {n m} → T (n <ᵇ m) → n < m
<ᵇ-sound {zero} {suc m} p = z<s
<ᵇ-sound {suc n} {suc m} p = s<s (<ᵇ-sound p)
#+end_src

* Evidência e Computação

- Completeness for <ᵇ

#+begin_src agda2
<ᵇ-complete : ∀ {n m} → n < m → T (n <ᵇ m)
<ᵇ-complete z<s = tt
<ᵇ-complete (s<s p) = <ᵇ-complete p
#+end_src

* Evidência e Computação

- Há alguma maneira de combinar a computação
  oferecida pelo teste baseado em valores
  booleanos e a produção de evidência?

- Sim! Para isso vamos utilizar um novo tipo.

* Evidência e Computação

- `Dec` é um tipo que representa proposições
  decidíveis.

#+begin_src agda2
data Dec {l}(A : Set l) : Set l where
  yes : A   → Dec A
  no  : ¬ A → Dec A
#+end_src

* Evidência e Computação

- Usando `Dec` podemos decidir desigualdades.

- Primeiro, um resultado auxiliar.

#+begin_src agda2 
<-suc-inv : ∀ {n m} → suc n < suc m → n < m
<-suc-inv (s<s p) = p
#+end_src

* Evidência e Computação

- Decidindo a desigualdade

#+begin_src agda2
_<?_ : ∀ (n m : ℕ) → Dec (n < m)
zero <? zero = no (λ ())
zero <? suc m = yes z<s
suc n <? zero = no (λ ())
suc n <? suc m with n <? m
...| yes n<m = yes (s<s n<m)
...| no ¬n<m = no (¬n<m ∘ <-suc-inv)
#+end_src

* Evidência e Computação

- Convertendo `Dec` em um booleano

#+begin_src agda2
⌞_⌟ : ∀ {l}{A : Set l} → Dec A → Bool
⌞ yes x ⌟ = true
⌞ no x ⌟  = false
#+end_src

* Evidência e Computação

- Obtemos a versão do teste para booleanos
simplesmente usando a função de conversão.

#+begin_src agda2
_≤ᵇ'_ : ℕ → ℕ → Bool
n ≤ᵇ' m = ⌞ n <? m ⌟
#+end_src

* Evidência e Computação

- Se o tipo `Dec` é equivalente a Bool,
  então existem funções sobre `Dec`
  similares aos conectivos da lógica?

- A resposta é sim!

* Evidência e Computação

- Conjunção para `Dec`

#+begin_src agda2
infixr 6 _×-dec_

_×-dec_ : ∀ {a b}{A : Set a}{B : Set b} → Dec A → Dec B → Dec (A × B)
yes x ×-dec yes x₁ = yes (x , x₁)
yes x ×-dec no x₁ = no (λ z → x₁ (proj₂ z))
no x ×-dec db = no (λ z → x (proj₁ z))
#+end_src

* Proof by reflection
  
- Uma aplicação importante do apresentado até o momento
é a técnica de proof by reflection.

- Como Agda é uma linguagem de programação e um assistente
  de provas, podemos usá-la para calcular uma "dedução"
  de acordo com o seu formato.

- Veremos essa técnica em um exemplo.

* Proof by reflection

- Recordando: predicado para números pares.

#+begin_src agda2
data Even : ℕ → Set where
  zero : Even 0
  suc  : ∀ {n} → Even n
               → Even (2 + n)
#+end_src

* Proof by reflection

- Uma definição alternativa para o predicado even.

#+begin_src agda2
even? : ℕ → Set
even? 0 = ⊤
even? (suc 0) = ⊥
even? (suc (suc n)) = even? n
#+end_src

* Proof by reflection

- Estabelencendo a equivalência entre as versões.

#+begin_src agda2 
soundness : ∀ {n} → even? n → Even n
soundness {zero} p = zero
soundness {suc (suc n)} p = suc (soundness p)

completeness : ∀ {n} → Even n → even? n
completeness zero = tt
completeness (suc p) = completeness p
#+end_src

* Proof by reflection

- Usando o lema `soundness` e o fato de que uma computação
de `even? n` reduz para um valor de tipo `⊤`, para n par
podemos obter uma dedução sem a construção efetiva de
uma árvore dedutiva.

#+begin_src agda2
_ : Even 1099864
_ = soundness tt
#+end_src

* Referências

- Kokke, Wen; Wadler, Phillip; Siek, Jeremy.
Programming Languages Foundations in Agda.

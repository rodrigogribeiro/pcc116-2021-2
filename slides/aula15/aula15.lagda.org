#    -*- mode: org -*-
#+TITLE: Listas em Agda
#+SUBTITLE: PCC102 - Teoria da computação
#+AUTHOR: Rodrigo Ribeiro
#+EMAIL: rodrigo.ribeiro@ufop.edu.br

* Setup inicial

#+BEGIN_SRC agda2
module aula15 where
    
  open import Basics.Level

  open import Data.Bool.Bool
  open import Data.Function.Function
  open import Data.Biconditional.Biconditional
  open import Data.Nat.Nat
  open import Data.Nat.Le
  open import Data.Product.Product renaming ( _,_ to _:,:_)

  open import Relation.Decidable.Dec
  open import Relation.Equality.Propositional

  _≥_ : ℕ → ℕ → Bool
  zero ≥ zero = true
  zero ≥ suc m = false
  suc n ≥ zero = true
  suc n ≥ suc m = n ≥ m
#+END_SRC

* Listas

- Um dos tipos de dados mais utilizados em
  linguagens funcionais são as listas.

- Essa é uma tradição que existe desde a
  linguagem Lisp e seus dialetos.

* Listas

- A definição de listas em Agda é feita
  pelo seguinte tipo indutivo.

#+begin_src agda2
  infixr 5 _∷_
  
  data List {a}(A : Set a) : Set a where
    []  : List A
    _∷_ : A → List A → List A
#+end_src

* Listas

- Sintaxe especial para listas.

#+begin_src agda2
  pattern [_] z = z ∷ []
  pattern [_,_] y z = y ∷ z ∷ []
  pattern [_,_,_] x y z = x ∷ y ∷ z ∷ []
  pattern [_,_,_,_] w x y z = w ∷ x ∷ y ∷ z ∷ []
  pattern [_,_,_,_,_] v w x y z = v ∷ w ∷ x ∷ y ∷ z ∷ []
  pattern [_,_,_,_,_,_] u v w x y z = u ∷ v ∷ w ∷ x ∷ y ∷ z ∷ []
#+end_src

* Listas

- Operações básicas sobre listas.

#+begin_src agda2
  length : ∀ {a}{A : Set a} → List A → ℕ
  length [] = 0
  length (x ∷ xs) = suc (length xs)

  _ : length (1 ∷ 2 ∷ []) ≡ 2
  _ = {!!}
#+end_src

* Listas

- Concatenação

#+begin_src agda2
  infixr 5 _++_

  _++_ : ∀ {a}{A : Set a} → List A → List A → List A
  [] ++ ys       = ys
  (x ∷ xs) ++ ys = x ∷ (xs ++ ys) 
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : [ 1 , 2 ] ++ [ 3 ] ≡ [ 1 , 2 , 3 ]
  _ = {!!}
#+end_src

* Listas

- Um teorema simples.

#+begin_src agda2
  length-++ : ∀ {a}{A : Set a}(xs ys : List A) →
              length (xs ++ ys) ≡ length xs + length ys
  length-++ xs ys = {!!}
#+end_src

* Listas

- A função `map`.

#+begin_src agda2
  map : ∀ {a b}{A : Set a}{B : Set b} →
          (A → B) → List A → List B
  map f []       = []
  map f (x ∷ xs) = f x ∷ map f xs
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : map suc [ 0 , 1 , 2 ] ≡ [ 1 , 2 , 3 ]
  _ = {!!}
#+end_src

* Listas

- Relacionando `map` e `++`

#+begin_src agda2
  map-++ : ∀ {a b}{A : Set a}{B : Set b}
             (f : A → B)(xs ys : List A) →
             map f (xs ++ ys) ≡ map f xs ++ map f ys
  map-++ f xs ys = {!!}
#+end_src

* Listas

- Relacionando `map` e `∘`:

#+begin_src agda2
  map-∘ : ∀ {a b c}{A : Set a}{B : Set b}{C : Set c}
            {g : B → C}{f : A → B}(xs : List A) →
            (map g ∘ map f) xs ≡ map (g ∘ f) xs
  map-∘ xs = {!!}
#+end_src

* Listas

- Invertendo uma lista, versão ineficiente.

#+begin_src agda2
  reverse : ∀ {a}{A : Set a} → List A → List A
  reverse []       = []
  reverse (x ∷ xs) = reverse xs ++ [ x ]
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : reverse [ 1 , 2 ] ≡ [ 2 , 1 ]
  _ = {!!}
#+end_src

* Listas

- `reverse` preserva `length`

#+begin_src agda2
  reverse-length : ∀ {a}{A : Set a}(xs : List A) →
                   length xs ≡ length (reverse xs)
  reverse-length xs = {!!}
#+end_src

* Listas

- Relacionando `reverse` e `++`

#+begin_src agda2
  reverse-++ : ∀ {a}{A : Set a}(xs ys : List A) →
              reverse (xs ++ ys) ≡ reverse ys ++ reverse xs
  reverse-++ xs ys = {!!}
#+end_src

* Listas

- Operador `foldr`

#+begin_src agda2
  foldr : ∀ {a b}{A : Set a}{B : Set b} →
            (A → B → B) → B → List A → B
  foldr _ v []       = v
  foldr f v (x ∷ xs) = f x (foldr f v xs) 
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : foldr _+_ 0 [ 1 , 2 , 3 ] ≡ 6
  _ = {!!}
#+end_src

* Listas

- Relacionando `foldr` e `++`

#+begin_src agda2
  foldr-++ : ∀ {a b}{A : Set a}{B : Set b}
               {_⊕_ : A → B → B}{ε : B}
               (xs ys : List A) →
               foldr _⊕_ ε (xs ++ ys) ≡ foldr _⊕_ (foldr _⊕_ ε ys) xs
  foldr-++ xs ys = {!!}
#+end_src

* Listas

- Função `filter`

#+begin_src agda2
  filter : ∀ {a}{A : Set a} → (A → Bool) → List A → List A
  filter p []       = []
  filter p (x ∷ xs) = let r = filter p xs
                      in if p x then x ∷ r else r
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : filter (_≥ 2) [ 1 , 2 , 5 , 1 , 4 ] ≡ [ 2 , 5 , 4 ]
  _ = {!!}
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  filter-length : ∀ {a}{A : Set a}{p : A → Bool}(xs : List A) →
                  length (filter p xs) ≤ length xs
  filter-length xs = {!!}
#+end_src

* Listas

- O predicado `All` denota que uma propriedade é válida
para todos os elementos de uma lista.

#+begin_src agda2
  data All {a b}{A : Set a}(P : A → Set b) : List A → Set (a ⊔ b) where
    []  : All P []
    _∷_ : ∀ {x xs} → P x → All P xs → All P (x ∷ xs)
#+end_src
  
* Listas

- Exemplo

#+begin_src agda2
  _ : All (λ x → T (x ≥ 2)) [ 3 , 1 , 4 , 0 ]
  _ = {!!}
#+end_src


* Listas

- Relacionando `All` e `++`

#+begin_src agda2
  All-++ : ∀ {a}{A : Set a}{P : A → Set a}(xs ys : List A) →
             All P (xs ++ ys) ⇔ (All P xs × All P ys)
  All-++ xs ys = {!!}
#+end_src


* Listas

- Indicando que uma propriedade é válida para algum
elemento de uma lista.

#+begin_src agda2
  data Any {a b}{A : Set a}(P : A → Set b) : List A → Set (a ⊔ b) where
    here  : ∀ {x xs} → P x → Any P (x ∷ xs)
    there : ∀ {x xs} → Any P xs → Any P (x ∷ xs)
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : Any (_≡ 2) [ 1 , 2 , 3 , 2 ]
  _ = {!!}
#+end_src

* Listas

- Predicado de pertinência em uma lista.

#+begin_src agda2
  infix 4 _∈_

  _∈_ : ∀ {a}{A : Set a} → A → List A → Set a
  x ∈ xs = Any (x ≡_) xs
#+end_src

* Listas

- Exemplo

#+begin_src agda2
  _ : 3 ∈ [ 1 , 2 , 3 , 2 ]
  _ = {!!}
#+end_src

* Listas

- Decidibilidade.

#+begin_src agda2
  Decidable : ∀ {a}{A : Set a} → (A → Set a) → Set a
  Decidable {_}{A} P = ∀ (x : A) → Dec (P x)
#+end_src


* Listas

- Decidibilidade de `All`

#+begin_src agda2
  All? : ∀ {a}{A : Set a}{P : A → Set a} → Decidable P → Decidable (All P)
  All? decP = {!!}
#+end_src

* Listas

- Isso conclui a nossa apresentação inicial sobre listas
e seus algoritmos usando a linguagem Agda.

- Na próxima aula, veremos um exemplo completo de verificação
de um algoritmo.

* Referências

- Kokke, Wen; Wadler, Phillip; Siek, Jeremy. Programming Languages Foundations in
Agda.
